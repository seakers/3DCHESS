import logging

from dmas.clocks import ClockConfig
from dmas.utils import runtime_tracker

from chess3d.messages import MeasurementRequestMessage
from chess3d.nodes.actions import BroadcastMessageAction
from chess3d.nodes.orbitdata import OrbitData
from chess3d.nodes.planning.plan import Plan, Replan
from chess3d.nodes.planning.planner import AbstractReplanner
from chess3d.nodes.science.requests import MeasurementRequest
from chess3d.nodes.states import SimulationAgentState

class Broadcaster(AbstractReplanner):
    def __init__(self, logger: logging.Logger = None) -> None:
        """ broadcasts whenever there are pending relays or measurement requests that have not been broadcasted """
        super().__init__(logger)
        self.pending_reqs_to_broadcast = set()

    def update_percepts(self, 
                        state: SimulationAgentState, 
                        current_plan: Plan, 
                        incoming_reqs: list, 
                        relay_messages: list, 
                        misc_messages: list, 
                        completed_actions: list, 
                        aborted_actions: list, 
                        pending_actions: list
                        ) -> None:
        super().update_percepts(state, current_plan, incoming_reqs, relay_messages, misc_messages, completed_actions, aborted_actions, pending_actions)

        # get list of measurement requests newly generated by the parent agent
        my_reqs = {req 
                   for req in incoming_reqs
                   if isinstance(req, MeasurementRequest)
                   and req.requester == state.agent_name}
        
        if my_reqs:
            x = 1

        # update list of pending requests to broadcast
        self.pending_reqs_to_broadcast.update(my_reqs)

        # remove from list of pending requests to breadcasts if they've been broadcasted already
        broadcasted_reqs = {MeasurementRequest.from_dict(msg.req) 
                            for msg in self.completed_broadcasts
                            if isinstance(msg, MeasurementRequestMessage)}
        for req in broadcasted_reqs:
            if req in self.pending_reqs_to_broadcast:
                self.pending_reqs_to_broadcast.remove(req)

        x = 1

    @runtime_tracker
    def needs_planning( self, 
                        state : SimulationAgentState,
                        current_plan : Plan
                        ) -> bool:
        """ only replans whenever there are any pending relays or requests to broadcasts to perform """

        return (len(self.pending_relays) > 0
                or len(self.pending_reqs_to_broadcast))
    
    def generate_plan(self, 
                      state : SimulationAgentState,
                      current_plan : Plan,
                      clock_config : ClockConfig,
                      orbitdata : OrbitData
                      ) -> Plan:
        
        # initialize list of broadcasts to be done
        broadcasts = self._schedule_broadcasts(state, orbitdata)
                                        
        # update and return plan with new broadcasts
        return Replan.from_preplan(current_plan, broadcasts, t=state.t)

    def _schedule_broadcasts(self, state: SimulationAgentState, orbitdata: OrbitData, **_) -> list:
        broadcasts = super()._schedule_broadcasts(state, orbitdata, **_)

        # schedule generated measurement request broadcasts
        if self.pending_reqs_to_broadcast:
            # find best path for broadcasts
            path, t_start = self._create_broadcast_path(state, orbitdata)

            # check feasibility of path found
            if t_start >= 0:
                # create a broadcast action for all unbroadcasted measurement requests
                while self.pending_reqs_to_broadcast:
                    # get next request to broadcast
                    req : MeasurementRequest = self.pending_reqs_to_broadcast.pop()

                    # create broadcast action
                    msg = MeasurementRequestMessage(state.agent_name, state.agent_name, req.to_dict(), path=path)
                    broadcast_action = BroadcastMessageAction(msg.to_dict(), t_start)
                    
                    broadcasts.append(broadcast_action)

        return broadcasts