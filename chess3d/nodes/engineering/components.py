from abc import ABC, abstractmethod
from typing import Union
import uuid

import numpy as np

from nodes.engineering.actions import *


class AbstractComponent(ABC):
    """
    # Abstract Component 

    Represents a generic component that is part of a subsystem onboard an agent's Engineering Module

    ### Attributes:
        - name (`str`) : name of the component
        - operatirng_power (`float`) : power consumed by this componen when enabled in watts [W]
        - status (`str`) : current status of the component
        - t (`float` or `int`) : last updated time
        - id (`str`) : identifying number for this task in uuid format
    """
    ENABLED = 'ENABLED'
    DISABLED = 'DISABLED'
    CRITICAL = 'CRITICAL'
    FAILED = 'FAILED'

    def __init__(   self, 
                    name : str,
                    operating_power : float,
                    status : str = DISABLED,
                    t : float = 0.0,
                    id : str = None
                    ) -> None:
        """
        Initiates an instance of an Abstract Component 

        ### Arguments:
            - name (`str`) : name of the component
            - operatirng_power (`float`) : power consumed by this componen when enabled in watts [W]
            - status (`str`) : initial status of the component
            - t (`float` or `int`) : initial updated time  
            - id (`str`) : identifying number for this component in uuid format
        """
        super().__init__()
                
        self.name = name
        self.operating_power = operating_power
        self.status = status
        self.t = t
        self.id = str(uuid.UUID(id)) if id is not None else str(uuid.uuid1())

    @abstractmethod
    def update(self, **kwargs) -> None:
        """
        Propagates and updates the current state of the component.
        """
        pass

    @abstractmethod
    def perform_action(self, action : ComponentAction, t : Union[int, float]) -> bool:
        """
        Performs an action on this component

        ### Arguments:
            - action (:obj:`ComponentAction`) : action to be performed
            - t (`float` or `int`) : current simulation time in [s]

        ### Returns:
            - boolean value indicating if performing the action was successful or not
        """
        self.t = t

    @abstractmethod
    def is_critical(self, **kwargs) -> bool:
        """
        Returns true if the component is in a critical state
        """
        pass

    @abstractmethod
    def is_failure(self, **kwargs) -> bool:
        """
        Returns true if the component is in a failure state
        """
        pass

    @abstractmethod
    def predict_critical(self, **kwags) -> float:
        """
        Given the current state of the component, this method predicts when a critical state will be reached.

        Returns the time where this will ocurr in simulation seconds.
        """
        pass

    @abstractmethod
    def predict_failure(self, **kwags) -> float:
        """
        Given the current state of the component, this method predicts when a failure state will be reached.

        Returns the time where this will ocurr in simulation seconds.
        """
        pass

    def to_dict(self) -> dict:
        """
        Crates a dictionary containing all information contained in this component object
        """
        return dict(self.__dict__)
    
    def __str__(self) -> str:
        return str(self.to_dict())
    
class Battery(AbstractComponent):
    """
    # Battery Component 

    Represents a battery that is part of the EPS sybstem onboard an agent's Engineering Module

    ### Attributes:
        - name (`str`) : name of component 
        - max_power_generation (`float`) : maximum power generated by the battery in watts [W]
        - energy_capacity (`float`) : maximum amount of energy a battery can hold in joules [J]
        - initial_energy_capacity (`float`) : maximum energy stored at the creation of a battery in joules [J]
        - energy_storaged (`float`) : amount of energy currently available in the battery in joules [J]
        - depth_of_discharge (`float`) : TODO
    """
    def __init__(   self, 
                    name : str,
                    max_power_generation : float,
                    energy_capacity : float,
                    depth_of_discharge : float = 0.99,
                    status : str = AbstractComponent.DISABLED,
                    id : str = None
                    ) -> None:
        """
        Initiates an instance of an Abstract Component 

        ### Arguments:
            - name (`str`) : name of the component
            - energy_capacity (`float`) : maximum amount of energy a battery can hold in joules [J]
            - status (`str`) : initial status of the component
            - t (`float` or `int`) : initial updated time  
            - id (`str`) : identifying number for this component in uuid format
        """
        super().__init__(name, 0.0, status=status, id=id)
                
        self.max_power_generation = max_power_generation
        self.inial_energy_capacity = energy_capacity
        self.energy_capacity = energy_capacity
        self.energy_stored = energy_capacity*0.9
        self.depth_of_discharge = depth_of_discharge
        self.p_in = 0.0
        self.p_out = 0.0

    def update(self, t : Union[int, float]):
        # check if component has NOT already failed
        if self.status != Battery.FAILED:
            # calculate current power load
            p_load = self.p_out - self.p_in

            # update energy stored 
            self.energy_stored -= p_load*(t - self.t)
            
            # check if in critical state
            if self.is_critical() and self.status != Battery.CRITICAL:
                # reduce maximum energy capacity
                self.energy_capacity *= 0.9

                # update internal state indicator
                self.status = Battery.CRITICAL

            # check if in failure state
            if self.is_failure():
                # lose all stored enery
                self.energy_capacity = 0.0
                self.energy_stored = 0.0

                # update internal state indicator
                self.status = Battery.FAILED
            
            # check if in nominal state
            if not self.is_critical() and not self.is_failure():
                # update internal state indicator
                self.status = Battery.ENABLED

        # update time 
        self.t = t

    def is_critical(self) -> bool:        
        return (    
                    self.energy_stored < (1 - self.depth_of_discharge)*self.energy_capacity # energy stored is below acceptable DoD
                or  self.energy_stored > 0.9*self.energy_capacity # energy stored is over acceptable levels
                )    

    def predict_critical(self) -> float:
        if self.is_critical():
            return 0.0
        
        # calculate current power load
        p_load = self.p_out - self.p_in

        if self.p_out < self.p_in: # battery is being charged
            return abs( (0.9*self.energy_capacity - self.energy_stored)/p_load )

        elif self.p_out > self.p_in: # battery is being drained
            return abs( (0.1*self.energy_capacity - self.energy_stored)/p_load )
        
        else: # battery is not in use
            return np.Inf
    
    def is_failure(self) -> bool:        
        return self.energy_capacity < 0.1*self.inial_energy_capacity # energy stored is below acceptable range

    def predict_failure(self) -> float:
        return np.Inf # TODO define a predictable failure mode

    def perform_action(self, action : ComponentAction, t : Union[int, float]) -> bool:
        """
        Performs an action on this component

        ### Arguments:
            - action (:obj:`ComponentAction`) : action to be performed
            - t (`float` or `int`) : current simulation time in [s]

        ### Returns:
            - boolean value indicating if performing the action was successful or not
        """
        # check if component is failed
        if self.is_failure():
            return False

        # handle action
        if isinstance(action, ComponentProvidePower):
            if self.p_out + action.receiver_power <= self.max_power_generation:
                # battery can provide the required power output
                self.p_out += action.receiver_power
                return True
            return False # cannot provide the required power output

        elif isinstance(action, ComponentStopProvidePower):
            if self.p_out - action.receiver_power >= 0.0:
                # battery can stop providing the required power output
                self.p_out -= action.receiver_power
                return True
            return False # battery was not initially providing the required power output
        
        elif isinstance(action, ComponentChargeBattery):
            self.p_in += action.charging_power
            return True
        
        elif isinstance(action, ComponentStopChargeBattery):
            if self.p_in - action.charging_power >= 0.0:
                # battery can stop receiving there required power input
                self.p_in -= action.charging_power 
                return True
            return False # battery was not being initially provided with the required power output
            
        else:
            raise NotImplemented(f"action of type {type(action)} not supported by Battery component.")

class SolarPanel(AbstractComponent):
    """
    # Solar Panel Component 

    Represents a solar panel that is part of the EPS sybstem onboard an agent's Engineering Module

    ### Attributes:
        - power (`float`) : maximum amount of power that a solar panel can provide
        - size (`float`) : the area of the solar array in meters squared
        - load (`float`) : the power strain due to the components the solar panel is powering
    """
    ECLIPSE = [(1500,2000),(3500,4000),(6500,7000),(9500,10000)]

    def __init__(   self, 
                    name : str,
                    size : float,
                    area_power : float,
                    dt : float,
                    operating_power : float = 0,
                    status : str = AbstractComponent.DISABLED,
                    id : str = None
                    ) -> None:
        """
        Initiates an instance of an Abstract Component 

        ### Arguments:
            - name (`str`) : name of the component
            - size (`str`) : the area of the solar array in meters squared
            - area_power (`str`) : power provided per square meter
            - status (`str`) : initial status of the component
            - t (`float` or `int`) : initial updated time  
            - id (`str`) : identifying number for this component in uuid format
        """
        super().__init__(name, operating_power, dt)
                
        if(self.is_failure()): 
            self.power = 0
        else:
            self.power = size * area_power
            
        self.size = size
        self.area_power = area_power
        self.load = 0

    def update(self, t : Union[int, float]):
        self.t = t

        if(self.is_failure()): 
            self.power = 0
        else:
            self.power = self.size * self.area_power

    def is_critical(self):
        for lapse in self.ECLIPSE:
            if lapse[0] <= self.t<=lapse[1]:
                self.status = super().CRITICAL
                return True
    
    def is_failure(self):
        for lapse in self.ECLIPSE:
            if self.t>=lapse[0] and self.t<=lapse[1]:
                self.status = super().FAILED
                return True

    def predict_critical(self):
        time_to_crit = 0
        for lapse in self.ECLIPSE:
            if abs(lapse[0]-self.t-self.dt) < time_to_crit or time_to_crit == 0:
                time_to_crit = abs(lapse[0]-self.t-self.dt)
        return time_to_crit

    def predict_failure(self):
        time_to_fail = 0
        for lapse in self.ECLIPSE:
            if abs(lapse[0]-self.t) < time_to_fail or time_to_fail == 0:
                time_to_fail = abs(lapse[0]-self.t)
        return time_to_fail

    def perform_action(self, action : ComponentAction, t : Union[int, float]) -> bool:
        """
        Performs an action on this component

        ### Arguments:
            - action (:obj:`ComponentAction`) : action to be performed
            - t (`float` or `int`) : current simulation time in [s]

        ### Returns:
            - boolean value indicating if performing the action was successful or not
        """
        self.t = t

        if isinstance(action, ComponentProvidePower):
            self.load += action.receiver_power
            self.status = super().ENABLED

        elif isinstance(action, ComponentStopProvidePower):
            self.load -= action.receiver_power
        
        elif isinstance(action, ComponentChargeBattery):
            self.load += action.charging_power


class Instrument(AbstractComponent):
    """
    # Instrument Component 

    Represents an instrument that is connected to a battery in the EPS sybstem onboard an agent's Engineering Module

    ### Attributes:
        - 
    """
    def __init__(   self, 
                    name : str,
                    operating_power: float,
                    dt : float,
                    t: float = 0,
                    id : str = None
                    ) -> None:
        """
        Initiates an instance of an Abstract Component 

        ### Arguments:
            - name (`str`) : name of the component
            - status (`str`) : initial status of the component
            - t (`float` or `int`) : initial updated time  
            - id (`str`) : identifying number for this component in uuid format
        """
        super().__init__(name, operating_power, dt)

    def update(self, t : Union[int, float]):
        self.t = t

    def is_critical(self):
        pass
    
    def is_failure(self):
        pass

    def predict_critical(self):
        pass

    def predict_failure(self):
        pass

    def perform_action(self, action : ComponentAction, t : Union[int, float]) -> bool:
        """
        Performs an action on this component

        ### Arguments:
            - action (:obj:`ComponentAction`) : action to be performed
            - t (`float` or `int`) : current simulation time in [s]

        ### Returns:
            - boolean value indicating if performing the action was successful or not
        """
        self.t = t

        if isinstance(action, ):
            pass